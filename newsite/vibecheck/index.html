<!DOCTYPE html>
<html><head>

    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Victorian Validator</title>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap'); 
        html { background-color: #684848; font-family: "Times New Roman"; color: #212529 }
        body { margin: 5em; margin-top: 1em; }
        div { display: flex; flex-direction: row; margin-top: 1em; }
        aside { background-color: #fff; height: fit-content; font-family: monospace; margin-right: 1em; padding: 1em; flex: 2; }
        main { background-color: #fff; padding: 1em; flex: 7; min-height: 60vh; }
        header { background-color: #fff; text-align: center; margin-left: auto; margin-right: auto; padding-top: 0.1em; padding-bottom: 0.1em; }
        em { font-style: normal }
        em.c { font-weight: bold; }
        em.f { font-style: italic; }
        em.r { text-decoration: underline; }
        button { border: 0; background-color: #684848; color: #fff; font-size: 1.25em; font-family: monospace; padding: 0.5em}
        button:hover { color: #000801b; }
    </style>

    <script type="text/javascript" src="data.js">
        // Contains two variable, wcorp and qcorp. Each is a dictionary of lists where each key is a letter and a number. The letter is the first letter of the word, the number is the length of the word. This is to make it unnecessary to sort through the entire list.
        // wcorp's lists consist of a list of words (types) that appear in the corpus of letter novels.
        // qcorp consists of lists of two values: first, the number of tokens in quotes; second, the number of tokens in total.
        // The values in wcorp and qcorp have the same index in the same key, so finding the index in wcorp finds the index in qcorp.
        // This should be faster than just checking if every token is in a dictionary's keys, hence the roundabout method.
        // Also contains a list of stopwords.
    </script>
    <script>

        var tl = [60679, 38510, 34543, 23175, 20499, 18368, 16267, 15656, 15038, 13577, 13107, 12304, 11840, 11078, 10614, 10199, 9578, 9094, 8339, 7750, 7589, 7383, 6878, 6462, 6101, 5780, 5306, 4979, 4761, 4502, 4237, 3964, 3725, 3489, 3218, 3025, 2880, 2706, 2571, 2428, 2286, 2139, 2017, 1905, 1809, 1698, 1613, 1529, 1451, 1351, 1274, 1185, 1131, 1069, 1018, 959, 902, 851, 816, 775, 735, 692, 650, 614, 578, 547, 510, 483, 450, 423, 394, 370, 344, 318, 297, 278, 258, 237, 219, 203, 186, 171, 154, 140, 127, 114, 102, 90, 80, 69, 59, 51, 42, 35, 27, 20, 14, 9, 4, 1]

        var mean = 0.16561 // Equivalent to the percent of tokens in quotation marks.
	var sd = 0.37173 // Square root of the average of each token's difference with the mean squared, where each token has a value of 1 if it is in quotes and 0 if it is not.

        function stupidsort(x) {
          for (var i = 99; i > -1; i--) {
            if (tl[i] >= x) { break }}
          return i }

        // True if l is a letter, false otherwise. Had previously checked against a string of letters, which was inefficient.
        function isalpha(l) {
            var ccode = l.charCodeAt() 
            return ((96 < ccode && ccode < 123) || (64 < ccode && ccode < 91))}

        // Breaks up the inputted text into parsable content.
        function process(text) {

            // ind: list of list of lists; each even-indexed list in the list is outside quotes, each odd-indexed is a quotation; each list contains the index in the text where a string of letters starts and then the index where it stops.
            // setting: if setting is 0, the last character was not a letter; if it was a letter, it is 1.
            // currpoint: equivalent at any point to ind[ind.length-1][ind[ind.length-1].length-1], or, the last token added.
            // inquotes: refers to whether the currpoint is in quotes.
            var ind = [[]]; var setting = 0; var currpoint = 0; var inquotes = 0

            // Spaces preserve the same number of characters as <br>. The last character is a Chinese character which is in Unicode but not in actual Chinese; it doesn't mean anything so I assumed it will never come up. Very odd very dubious all-nighter decisions.
            var optext = text.replace(/<br>/g,'   彁')

            for (var i = 0; i < text.length; i++) {

                if (!setting && isalpha(optext[i])) { // If the last character was not a letter and this one is...
                    ind[ind.length-1].push([]) // Add a new list (to be a pair of indices) to the last quote/unquote list of words.
                    ind[ind.length-1][currpoint].push(i) // Add the current index to that list.
                    setting = 1 }

                else if (setting && !isalpha(optext[i])) { // If the last character was a letter and this one is not...
                    ind[ind.length-1][currpoint].push(i) // Add the current index to the last pair of word indices.
                    currpoint += 1 // Edit the next list of word indices yet (which has not yet been pushed).
                    setting = 0 }

                if ('"“”'.indexOf(optext[i]) > -1 || (optext[i] == '彁' && inquotes == 1)) { // If the current character is a quotation mark or a quote is ongoing and a newline is reached (demanding a quotation mark in the new paragraph to continue)...
                    ind.push([]) // Begin a new quote/unquote list.
                    currpoint = 0 // The new pair of word indices will be the first in the new list.
                    inquotes = 1 - inquotes } // Whatever the inquotes was before, it's the opposite.

            } return ind }

        // Evaluates each word by presence in the wordlist, whether it is rare, and whether it tends to be used as it is currently used (i.e. in or out of quotes).
        // If c is set to 1, just strips the text of formatting.
        function validate(c=0) {

            // Gets the text of the input field. Notably does not get the HTML so any existing tags are ignored; it will return HTML, not text.
            var text = document.getElementById('input').innerText

            // Normalizes newlines such that there are not more than two in a row. Then replaces them with the HTML.
            while (text.indexOf('\n\n\n') > -1) { text = text.replace(/\n\n\n/g,'\n\n') }
            text = text.replace(/\n/g,'<br>')

            if (!c) {

                if (isalpha(text[text.length - 1])) { text = text + '.' } // Adds a terminal period if the last character is a letter. Otherwise there will be no final index for the final word.
                var indices = process(text) // Gets the indices of all the tokens in the input.
                var catchup = 0 // Catchup refers to the extra characters added to the text for tags, added to the indices so they remain accurate.
                var quote = 1 // Quote is 1 if current word is in quotes and -1 if it is outside of quotes.
                var btoi = [0,0] // Stands for bold-to-italic. Bolded words appear in the correct context, italicized words appear outside of it.
                overhue = []; for (var i = 0; i < 101; i++) { overhue.push(0) }

                for (var sec = 0; sec < indices.length; sec++) { // Goes through each list within the list of lists of lists of indices, whose structure is defined in the comments for process().

                    quote = 0 - quote // By definition, this list of indices is in quotes if the former is not, and vice versa.

                    for (var w = 0; w < indices[sec].length; w++) { // Goes through each list of substring indices in the current sec.

                        var cut = text.substring(indices[sec][w][0]+catchup, indices[sec][w][1]+catchup); var cap = false
                        if (cut[0] == cut[0].toUpperCase()) { cap = true }
                        cut = cut.toLowerCase() // Gets the lowercase substring of the text as defined in the current list of substring indices indexed by w. Adjusts for catchup.
                        var key = cut[0]+cut.length // Gets the key for wcorp/qcorp access: the first letter plus the length of the word.

                        if (cap) { continue }
                        else if (!(wcorp[key] && wcorp[key].indexOf(cut) > -1)) {
                          if (cap) { continue }
                          else {
                            var ins = '<em class="f" data-rarity="'+100+'">'
                            overhue[100] += 1 }}
                        else {
                            var ins = ''; var lean = 0 // ins refers to the <em> tag for this specific token. lean refers to whether the word tends to appear in quotes or not.
                            var wordata = qcorp[key][wcorp[key].indexOf(cut)] // The value stored for the type of the token in qcorp.
                            var ratio = wordata[0]/wordata[1] // The percent of that type appear in quotes.

                            if (ratio-sd*2/wordata[1]**0.5 > mean) { lean = 1 } // If the lower bound for the 95% confidence interval for appearance in quotes is greater than the mean, it has a bias to appear in quotes.
                            else if (ratio+sd*2/wordata[1]**0.5 < mean) { lean = -1 } // If the upper bound for the 95% confidence interval for appearance in quotes is lesser than the mean, it has a bias to appear out of quotes.

                            if (stopwords.indexOf(cut) > -1) { ins = '<em>' } // If the token is a stopword or it appears at least 25 times in the corpus (this would need to be changed in a larger corpus) and has no lean, its tag is just <em>.
                            else {
                                ssrar = stupidsort(wordata[1])
                                overhue[ssrar] += 1
                                ins = '<em data-rarity="'+ssrar+'">'
                                if (lean * quote == 1) { btoi[0] += 1 } // If the quote lean is correct, assign the c (bold) class. The tag is not closed because the rarity has not been evaluated yet. Also increase the bold side of the btoi.
                                else if (lean * quote == -1) { btoi[1] += 1 }}} // Same as above for incorrect (italic) lean. Increases italic side of btoi.

                        text = text.substring(0,indices[sec][w][1] + catchup)+'</em>'+text.substring(indices[sec][w][1] + catchup,text.length) // Add the closing em tag at the end of the token in question, making up for catchup.
                        text = text.substring(0,indices[sec][w][0] + catchup)+ins+text.substring(indices[sec][w][0] + catchup,text.length) // Add the opening em tag as specified in ins before the token in question. Doing this after the closing tag allows catchup to be modified after.
                        catchup += ins.length + 5 // The length of the opening tag plus the length of the closing tag (always 5).

                }} document.getElementById('ratio').innerText = 'Usual to unusual context: ' + btoi[0]+':'+btoi[1]+['',' ('+Math.round(btoi[0]/btoi[1]*10)/10+':1)'][0 + (btoi[0] != 0 && btoi[1] != 0)] } // Displays the bold-to-italic information for the entire text in ratio and decimal form.

           document.getElementById('input').innerHTML = text // The text of the input has been converted into valid HTML.

           if (!c) {

               var hue = overhueval()
               document.getElementById('huescore').innerText = 'Score: '+Math.round(hue)+'%'
               hue = gradiant(1-hue/100)
               document.getElementById('huescore').style.backgroundColor = "rgb("+hue[0]+","+hue[1]+","+hue[2]+")"

               for (var emphasis of document.getElementsByTagName('em')) {
                   if (emphasis.className != 'f') { emphasis.addEventListener('click', inform) }
                   hue = gradiant(emphasis.dataset['rarity']/100)
                   if (emphasis.dataset['rarity'] != undefined) {
                       emphasis.style.color = 'rgb('+hue[0]+','+hue[1]+','+hue[2]+')' }}}} // Makes each valid token clickable to display information.

        // Displays information upon clicking a token.
        function inform() {
               var word = this.innerText.toLowerCase() // Word must be lowercase as all words in wcorp are.
               var key = word[0]+word.length // Gets key for qcorp and wcorp.
               var wordata = qcorp[key][wcorp[key].indexOf(word)] // Finds the qcorp data for the word in question.
               var prop = wordata[0]/wordata[1] // Converts that data into the mean, which is equivalent to the average of tokens where 1 is in quotes and 0 is out of quotes.
               var limit = sd/wordata[1]**0.5
               var infobox = document.getElementById('info')

               document.getElementById('info').innerText = 'Word "'+word+'" appears '+wordata[1]+' times, '+wordata[0]+' in quotations.\n'+Math.round(prop*100)+'\% quoted.'
               if (stopwords.indexOf(word) == -1 && mean != prop) { // Do not display these statistics for stopwords.
                   infobox.innerText += ' This proportion'
                   var deviance = Math.abs((mean-prop)/limit)
                   if (deviance < 1) { infobox.innerText += ' is not significantly' }
                   else if (deviance < 2) { infobox.innerText += ' only might be significantly' }
                   else if (deviance < 3) { infobox.innerText += ' is significantly' }
                   else { infobox.innerText += 'is very significantly' }
                   if (mean < prop) { infobox.innerText += ' greater' }
                   else { infobox.innerText += ' lesser' }
                   infobox.innerText += ' than the total proportion of quoted text ('+Math.floor(mean*1000+0.5)/10+'%).' }
        }

        function gradiant(d,c=1,i=2) {
            var rgb = [0,0,0]
            if (!i) { rgb[c-1] = Math.floor(255*d) }
            else {
                if (d >= 0.5) {
                    rgb[c-1] = 255
                    rgb[i-1] = Math.floor(255*(1-2*(d-0.5)))
                } else {
                    rgb[i-1] = 255
                    rgb[c-1] = Math.floor(255*2*d)
            }} return rgb }

        function overhueval() {
            var points = 100
            var total = overhue.reduce(function (x,y) { return x+y })
            var curtotal = overhue[100]
            if (curtotal) { points -= 1 }
            for (i = 99; i > -1; i--) {
              curtotal += overhue[i]
              if (curtotal/total*100 > 100 - i) { points -= curtotal/total }}
            return points }

    </script>

</head>

<body lang="en-US">

    <header><h1>Victorian Vibe Check</h1></header>
    <div>
        <aside>
            <button type="button" onclick="validate()">Evaluate</button>
            <button type="button" onclick="validate(1)">Clear</button>
            <p>Regular: Word has not been evaluated.</p>
            <p><em data-rarity='0'>Colour 1:</em> Extremely common word.</p>
            <p><em data-rarity='50'>Colour 2:</em> Fairly common word.</p>
            <p><em data-rarity='100'>Colour 3:</em> Very uncommon word.</p>
            <p><em data-rarity='100' class='f'>Italicized</em>: word does not appear in the Victorian corpus.</p>
            <hr>
            <p id='info'>Clicking a valid word displays its use statistics here.</p>
            <hr>
            <p id='ratio'>The ratio of words in their usual versus unusual context (i.e. in or out of quotations).</p>
            <hr>
            <div id='huescore' style='display: inline-block; padding: 0.5em; font-size: 1.25em; background-color: #684848; width: calc(100% - 1em); margin-top: 0; color: #fff; text-align: center'>Overall Score</div>
        </aside>

        <main contenteditable="true" id="input">
        </main>
    </div>

</body></html>
